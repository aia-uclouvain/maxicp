/*
 * MaxiCP is under MIT License
 * Copyright (c)  2023 UCLouvain
 */

package org.maxicp.search;

import org.maxicp.cp.engine.core.CPIntVar;
import org.maxicp.cp.engine.core.CPIntervalVar;
import org.maxicp.cp.engine.core.CPVar;
import org.maxicp.modeling.concrete.ConcreteModel;
import org.maxicp.state.State;
import org.maxicp.state.StateManager;
import org.maxicp.util.exception.InconsistencyException;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BooleanSupplier;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * An abstract search method, implementing all the parts needed, but the search method itself.
 *
 * @param <T> the type of the branching
 */
public abstract class AbstractSearchMethod<T> implements SearchMethod {
    protected Supplier<T[]> branching;
    protected StateManager sm;

    protected List<Runnable> solutionListeners = new LinkedList<Runnable>();
    protected List<Runnable> failureListeners = new LinkedList<Runnable>();

    public AbstractSearchMethod(StateManager sm, Supplier<T[]> branching) {
        this.sm = sm;
        this.branching = branching;
    }

    /**
     * Adds a listener that is called on each solution.
     *
     * @param listener the closure to be called whenever a solution is found
     */
    public void onSolution(Runnable listener) {
        solutionListeners.add(listener);
    }

    /**
     * Adds a listener that is called whenever a failure occurs
     * and the search backtracks.
     * This happens that when a {@link InconsistencyException} is thrown
     * when executing the closure generated by the branching.
     *
     * @param listener the closure to be called whenever a failure occurs and
     *                 the search need to backtrack
     */
    public void onFailure(Runnable listener) {
        failureListeners.add(listener);
    }

    protected void notifySolution() {
        solutionListeners.forEach(Runnable::run);
    }

    protected void notifyFailure() {
        failureListeners.forEach(Runnable::run);
    }

    protected SearchStatistics solve(SearchStatistics statistics, Predicate<SearchStatistics> limit, Runnable onNodeVisit) {
        sm.withNewState(() -> {
            try {
                // runs the visit of the root node
                onNodeVisit.run();
            } catch (InconsistencyException e) { // may happen due to tightening of an objective
                statistics.setCompleted();
            }
            if (!statistics.isCompleted()) {
                try {
                    startSolve(statistics, limit, onNodeVisit);
                    statistics.setCompleted();
                } catch (StopSearchException ignored) {

                }
            }
        });
        return statistics;
    }


    /**
     * Start the solving process
     *
     * @return an object with the statistics on the search
     */
    public SearchStatistics solve() {
        SearchStatistics statistics = new SearchStatistics();
        return solve(statistics, stats -> false, () -> {
        });
    }

    /**
     * Start the solving process
     * with a given listener of the search process.
     *
     * @param listener a listener of the search process
     * @return an object with the statistics on the search
     */
    public SearchStatistics solve(DFSListener listener) {
        SearchStatistics statistics = new SearchStatistics();
        return solve(statistics, stats -> false, () -> {
        });
    }

    /**
     * Start the solving process
     * with a given predicate called at each node
     * to stop the search when it becomes true.
     *
     * @param limit a predicate called at each node
     *              that stops the search when it becomes true
     * @return an object with the statistics on the search
     */
    public SearchStatistics solve(Predicate<SearchStatistics> limit) {
        SearchStatistics statistics = new SearchStatistics();
        return solve(statistics, limit, () -> {
        });
    }


    /**
     * Start the solving process
     * with a given predicate called at each node
     * to stop the search when it becomes true.
     * The state manager saves the state
     * before executing the closure
     * and restores it after the search.
     * Any {@link InconsistencyException} that may
     * be throw when executing the closure is also catched.
     *
     * @param limit     a predicate called at each node
     *                  that stops the search when it becomes true
     * @param subjectTo the closure to execute prior to the search starts
     * @return an object with the statistics on the search
     */
    public SearchStatistics solveSubjectTo(Predicate<SearchStatistics> limit, Runnable subjectTo) {
        SearchStatistics statistics = new SearchStatistics();
        sm.withNewState(() -> {
            try {
                subjectTo.run();
                solve(statistics, limit, () -> {
                });
            } catch (InconsistencyException ignored) {
            }
        });
        return statistics;
    }

    public boolean allFixed(CPVar[] vars) {
        for (CPVar v : vars) {
            if (!v.isFixed()) {
                return false;
            }
        }
        return true;
    }

    public static class IntRef {
        public int value;
    }

    public SearchStatistics replaySubjectTo(DFSLinearizer linearizer, CPVar[] variables, Runnable subjectTo, Objective obj) {
        Runnable toTighten = obj::tighten;
        onSolution(toTighten);
        SearchStatistics stats = replaySubjectTo(linearizer, variables, subjectTo, obj::filter);
        solutionListeners.remove(toTighten);
        return stats;
    }


    private long panic(BooleanSupplier stoppingCondition,
                       DFSLinearizer linearizer,
                       IntRef index) {
        /*
        long beforePanicTime = System.currentTimeMillis();
        while (invariant.getAsBoolean() && index.value < linearizer.size() - 1) {
            index.value++;
            Action next = linearizer.get(index.value);
            if (!(next instanceof BranchingAction)) next.run();
        }
        return System.currentTimeMillis() - beforePanicTime;
        */
        long t0 = System.currentTimeMillis();
        if (index.value >= linearizer.size() - 1) return 0;
        // we are sure that the next action is a RestoreStateAction
        do {
            index.value++;
            Action next = linearizer.get(index.value);
            if (!(next instanceof BranchingAction)) next.run(); // only do push/pop
        } while (!stoppingCondition.getAsBoolean() && index.value < linearizer.size());
        return System.currentTimeMillis() - t0;
    }

    public SearchStatistics replay(DFSLinearizer linearizer, CPVar[] variables) {
        return replaySubjectTo(linearizer, variables, () -> {
        });
    }

    public SearchStatistics replaySubjectTo(DFSLinearizer linearizer, CPVar[] variables, Runnable subjectTo) {
        return replaySubjectTo(linearizer, variables, subjectTo, () -> {});
    }

    public SearchStatistics replaySubjectTo(DFSLinearizer linearizer, CPVar[] variables, Runnable subjectTo, Runnable onNodeVisit) {
        SearchStatistics statistics = new SearchStatistics();
        sm.withNewState(() -> {
            try {
                subjectTo.run();
                State<Boolean> consistentState = sm.makeStateRef(true);
                IntRef index = new IntRef();
                index.value = 0;
                long panicTime = 0;
                while (index.value < linearizer.size()) {
                    Action action = linearizer.get(index.value);
                    if (action instanceof BranchingAction) {
                        onNodeVisit.run(); // filter the objective
                        statistics.incrNodes();
                    }
                    try {
                        action.run();
                    } catch (InconsistencyException e) {
                        consistentState.setValue(false);
                    }
                    if (!consistentState.value()) {
                        // failure => apply trail operations only until consistency is restored
                        statistics.incrFailures();
                        notifyFailure();
                        panicTime += panic(consistentState::value, linearizer, index);
                    } else if (allFixed(variables)) {
                        // all variables are fixed => apply trail operations only until not all variables are fixed anymore
                        statistics.incrSolutions();
                        notifySolution();
                        panicTime += panic(() -> !allFixed(variables), linearizer, index);
                    }
                    index.value++;
                }
                if (index.value == linearizer.size()) {
                    statistics.setCompleted();
                }
            } catch (InconsistencyException ignored) {
            }
        });
        return statistics;
    }


    /**
     * Start the solving process with a given objective.
     *
     * @param obj the objective to optimize that is tightened each
     *            time a new solution is found
     * @return an object with the statistics on the search
     */
    public SearchStatistics optimize(Objective obj) {
        return optimize(obj, stats -> false);
    }


    public SearchStatistics optimize(org.maxicp.modeling.symbolic.Objective obj, Predicate<SearchStatistics> limit) {
        ConcreteModel model = obj.getModelProxy().getConcreteModel();
        Objective objective = model.createObjective(obj);
        return optimize(objective, limit);
    }


    public SearchStatistics optimize(org.maxicp.modeling.symbolic.Objective obj) {
        return optimize(obj, stats -> false);
    }


    /**
     * Start the solving process with a given objective
     * and with a given predicate called at each node
     * to stop the search when it becomes true.
     *
     * @param toTighten the objective to optimize that is tightened each
     *                  time a new solution is found
     * @param limit     a predicate called at each node
     *                  that stops the search when it becomes true
     * @return an object with the statistics on the search
     */
    public SearchStatistics optimize(Objective toTighten, Predicate<SearchStatistics> limit) {
        SearchStatistics statistics = new SearchStatistics();
        Runnable tighten = toTighten::tighten;
        onSolution(tighten);
        try {
            solve(statistics, limit, toTighten::filter);
        } catch (InconsistencyException ignored) {
            ignored.printStackTrace();
        }
        solutionListeners.remove(tighten); // make sure we don't keep the objective active
        return statistics;
    }

    /**
     * Executes a closure prior to effectively
     * starting a branch and bound depth-first-search
     * with a given objective to optimize
     * and a given predicate called at each node
     * to stop the search when it becomes true.
     * The state manager saves the state
     * before executing the closure
     * and restores it after the search.
     * Any {@link InconsistencyException} that may
     * be thrown when executing the closure is also catched.
     *
     * @param objToTighten the objective to optimize that is tightened each
     *                     time a new solution is found
     * @param limit        a predicate called at each node
     *                     that stops the search when it becomes true
     * @param subjectTo    the closure to execute prior to the search starts
     * @return an object with the statistics on the search
     */
    public SearchStatistics optimizeSubjectTo(Objective objToTighten, Predicate<SearchStatistics> limit, Runnable subjectTo) {
        AtomicReference<SearchStatistics> statistics = new AtomicReference<>(new SearchStatistics());
        sm.withNewState(() -> {
            try {
                subjectTo.run();
                statistics.set(optimize(objToTighten, limit));
            } catch (InconsistencyException ignored) {
            }

        });
        return statistics.get();
    }


    public SearchStatistics optimizeSubjectTo(org.maxicp.modeling.symbolic.Objective objToTighten, Predicate<SearchStatistics> limit, Runnable subjectTo) {
        AtomicReference<SearchStatistics> statistics = new AtomicReference<>(new SearchStatistics());
        sm.withNewState(() -> {
            try {
                subjectTo.run();
                statistics.set(optimize(objToTighten, limit));
            } catch (InconsistencyException ignored) {
            }

        });
        return statistics.get();
    }

    /**
     * Start the solving process.
     * <p>
     * This method must be implemented by subclasses and do the heavy work.
     * It must call notifySolution/notifyFailure when a solution is found or a failure occurs.
     *
     * @param statistics
     * @param limit
     * @param onNodeVisit a closure to execute at each node visit
     */
    protected abstract void startSolve(SearchStatistics statistics, Predicate<SearchStatistics> limit, Runnable onNodeVisit);
}
